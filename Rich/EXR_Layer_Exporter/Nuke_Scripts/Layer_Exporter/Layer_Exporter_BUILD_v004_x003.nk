#! C:/Program Files/Nuke10.5v4/nuke-10.5.4.dll -nx
version 10.5 v4
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="-8" y="-8" w="2576" h="1456" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="1674"/>
            <splitter orientation="1">
                <split size="1058"/>
                <dock id="" activePageId="uk.co.thefoundry.scripteditor.1">
                    <page id="uk.co.thefoundry.scripteditor.1"/>
                </dock>
                <split size="612"/>
                <dock id="" activePageId="Properties.1" focus="true">
                    <page id="Properties.1"/>
                </dock>
            </splitter>
            <split size="882"/>
            <splitter orientation="2">
                <split size="695"/>
                <dock id="" hideTitles="1" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="695"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name D:/rbobo/Dropbox/CODE_aw_projects/aw_projects/EXR_Layer_Exporter/Nuke_Scripts/Layer_Exporter/Layer_Exporter_BUILD_v004_x003.nk
 frame 2
 last_frame 1
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement OCIO
 OCIO_config custom
 customOCIOConfigPath //isln-smb.armstrong-white.com/library/OCIO_Configs/aw_Comp_aces_1.0.3/aw_Comp_config.ocio
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT "ACES - ACES2065-1"
 monitorLut AW/sRGB_ICC(sRGB)
 int8Lut sRGB
 int16Lut sRGB
 logLut "ACES - ACES2065-1"
 floatLut "ACES - ACES2065-1"
}
Read {
 inputs 0
 file /Users/richbobo/Desktop/Pepto_12oz_FtNu_35mm_12oz_Bottle_NoLabel_0001.exr
 localizationPolicy on
 format "3000 3000 0 0 3000 3000 1 "
 origset true
 in_colorspace "ACES - ACEScg"
 out_colorspace "ACES - ACEScg"
 name Read9
 xpos -731
 ypos 206
 disable true
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet9
 xpos -731
 ypos 285
 disable true
}
Read {
 inputs 0
 file /Users/richbobo/Desktop/Pepto_12oz_FtNu_35mm_12oz_Label_MaxOrig_BTY_0001.exr
 localizationPolicy on
 format "3000 3000 0 0 3000 3000 1 "
 origset true
 in_colorspace "ACES - ACEScg"
 out_colorspace "ACES - ACEScg"
 name Read10
 xpos -595
 ypos 205
 disable true
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet10
 xpos -595
 ypos 283
 disable true
}
Read {
 inputs 0
 file C:/Users/rbobo/Desktop/TESTING/empty.exr
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 origset true
 name Read11
 xpos -456
 ypos 107
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet11
 xpos -456
 ypos 193
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/TESTING_1_2_3.exr
 localizationPolicy on
 format "2000 1125 0 0 2000 1125 1 "
 origset true
 colorspace "ACES - ACES2065-1"
 name Read8
 xpos -738
 ypos 63
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet8
 xpos -738
 ypos 153
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/img/comp/apple_cucumber/v001/apple_cucumber_drink_v001.exr
 localizationPolicy on
 format "2048 2048 0 0 2048 2048 1 square_2K"
 origset true
 colorspace "ACES - ACES2065-1"
 name Read7
 xpos -738
 ypos -81
}
set N7a91800 [stack 0]
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet7
 xpos -738
 ypos 10
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/ACES_WORKFLOW/CHOBANI_TEST/footage/BTY/Chobani_Drinks_BTY_0001.exr
 localizationPolicy on
 format "12000 12000 0 0 12000 12000 1 "
 origset true
 colorspace "ACES - ACES2065-1"
 name Read3
 xpos -74
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet6
 xpos -74
 ypos -144
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/ACES_WORKFLOW/dfulmer/elantra_test/white.exr
 localizationPolicy on
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 origset true
 colorspace "ACES - ACES2065-1"
 name Read5
 xpos -203
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet5
 xpos -203
 ypos -144
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/ACES_WORKFLOW/dfulmer/elantra_test/red_q50_0000.exr
 localizationPolicy on
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 origset true
 colorspace "ACES - ACES2065-1"
 name Read4
 xpos -336
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet3
 xpos -336
 ypos -144
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/EXR_REBUILD_IN_PHOTOSHOP/EXRs/2016Elantra_Int360_Value_0001.exr
 localizationPolicy on
 format "2000 1125 0 0 2000 1125 1 "
 origset true
 colorspace "ACES - ACES2065-1"
 name Read6
 xpos -479
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet4
 xpos -479
 ypos -144
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/ElantraGray8frame_v06_LimTech_0001_16bit_RETOUCHED_LAYERS.exr
 localizationPolicy on
 format "2000 1125 0 0 2000 1125 1 "
 origset true
 colorspace "ACES - ACES2065-1"
 name Read2
 xpos -617
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet2
 xpos -617
 ypos -144
}
Read {
 inputs 0
 file /Users/richbobo/Dropbox/richbobo/NUKE/Photoshop_and_Nuke/___Photoshop_Outputs_TESTING___/Mazda_CX5_Bty_int_parch_0004.exr
 localizationPolicy on
 format "2000 2000 0 0 2000 2000 1 "
 origset true
 colorspace "ACES - ACES2065-1"
 name Read1
 xpos -742
 ypos -234
}
LayerContactSheet {
 center true
 showLayerNames true
 name LayerContactSheet1
 xpos -742
 ypos -144
}
Viewer {
 inputs 8
 frame 2
 frame_range 1-1
 input_number 9
 viewerProcess "sRGB_ICC(sRGB) (AW)"
 name Viewer1
 xpos -435
 ypos -3
}
Group {
 inputs 0
 name EXR_Layer_Exporter
 knobChanged "\ndef knobChanged():\n    Node = nuke.thisNode()\n    Knob = nuke.thisKnob()\n    if Knob.name() == 'filetype':\n        if Knob.value() == 'exr':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setEnabled(True)\n        elif Knob.value() == 'tga':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\n        else:\n            Node.knob('icc_profile').setEnabled(True)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\nknobChanged()\n"
 xpos -240
 ypos 284
 disable true
 addUserKnob {20 auto_tab l Automatic}
 addUserKnob {26 ""}
 addUserKnob {2 dest_dir l "Output Directory:"}
 dest_dir C:/Users/rbobo/Desktop/TESTING/CRAP_08
 addUserKnob {26 ""}
 addUserKnob {68 filetype l "Image Type:" M {png tif jpg exr tga "" ""}}
 addUserKnob {6 exr_consolidate l "Consolidate Layers (Single EXR File)" +DISABLED +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {4 icc_profile l "ICC Profile:" M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc Rec2020.icc "ACESCG Linear.icc" "" ""}}
 icc_profile sRGB.icc
 addUserKnob {26 ""}
 addUserKnob {22 do_it l "Do it." T "import nuke\nimport EXR_Layer_Exporter.EXR_ValidLayers_Checker as LayersChecker\nimport CollectSourceFiles.SourceNodeInfo\n\n#------------------------------------------------------------------------\n# The Group node itself...\nGroupNode = nuke.thisNode()\n\n# Get the EXR Read node connected to the Group's input...\ntry:\n    ConnectedNode = GroupNode.input(0)\n    if (ConnectedNode.Class() == 'Read') and (os.path.splitext(nuke.filename(ConnectedNode))\[-1] == \".exr\"):\n        pass\n    else:\n        nuke.message(\"Please connect an EXR file to the input!\")\nexcept AttributeError:\n    nuke.message(\"Please connect an EXR file to the input!\")\n\n# The Output Directory knob for the user to set...\nuser_input = GroupNode.knob('dest_dir').value()\n\n# ICC Profile to add to image...\nICC_Profile_Name = GroupNode.knob('icc_profile').value()\n\n# Initialize the NodeInfo class to get parameters from the Read node...\nSource = CollectSourceFiles.SourceNodeInfo.NodeInfo()\n#READINFO = Source.get_info(ConnectedNode).items()\n#READINFO.sort()\n#print '\\n'\n#for k, v in READINFO:\n    #print k, '---->', v\n\nfirst = Source.get_info(ConnectedNode)\['firstFrame']\nlast = Source.get_info(ConnectedNode)\['lastFrame']\nFrameRange = \[(int(first), int(last), 1)]\n\n#------------------------------------------------------------------------\n\ndef directory_path_check(user_input):\n    '''\n    Make sure the destination directory path is of the correct form...\n    '''\n    destDir = ''\n    if user_input != '':\n        destDir = user_input\n        # Check to make sure a file path is not passed through\n        if os.path.isfile(destDir):\n            destDir = os.path.dirname(destDir)\n        # Make sure target path ends with a slash (for consistency)\n        if not destDir.endswith('/'):\n            destDir += '/'\n        return destDir\n    else:\n        return None\n    # Return the chosen directory path...\n    return destDir\n\n\ndef write_layers_to_separate_files(destDir, FileType=''):\n    ''''''\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    #--------------------------------------------------------------------\n    #  NODE REMOVALS\n    #--------------------------------------------------------------------\n    # Remove any leftover group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class() == ('Write') and Node.name() == 'Write_EXR':\n                pass\n            elif Node.Class() == ('Input'):\n                pass\n            elif Node.Class() == ('Output'):\n                pass\n            else:\n                nuke.delete(Node)      \n    except ValueError:\n        print 'Value Error: Check in Group for nodes that were not deleted...'    \n    #--------------------------------------------------------------------\n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    WriteNodes = \[]\n    ShuffleNodes = \[]\n\n    # Get only the non-empty layers...\n    layers = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[0]\n    #print layers\n\n    # Get the selected image file type to render...\n    FileType = GroupNode.knob('filetype').value()\n\n    for layer in layers:\n        ShuffleNode = nuke.createNode('Shuffle', inpanel=False)\n        ShuffleNode.knob('in').setValue(str(layer))\n        # Make sure the Shuffle node's input is connected to the Group's Input node...\n        ShuffleNode.setInput(0, InputNode)\n        ShuffleNodes.append(ShuffleNode)\n\n        WriteNode = nuke.createNode('Write', inpanel=False)\n        WriteNode.knob('file').setValue(str(destDir) + str(layer) + '_%04d' + '.' + FileType)\n        WriteNode.knob('use_limit').setValue(True)\n        WriteNode.knob('first').setValue(first)\n        WriteNode.knob('last').setValue(last)\n        # Make sure the Write node's input is connected to the Shuffle...\n        WriteNode.setInput(0, ShuffleNode)\n        # Add selected ICC Profile...\n        WriteNode.knob('ICC_knob').setValue(ICC_Profile_Name)\n        if layer is not 'rgba':\n            WriteNode.knob('channels').setValue('rgb')\n        else:\n            WriteNode.knob('channels').setValue('rgba')\n        WriteNodes.append(WriteNode)\n    print 'WriteNodes', WriteNodes\n\n    # Execute() takes a string for the node name, executeMultiple() takes a tuple of node objects...\n    # Single Write node...\n    if len(WriteNodes) == 1:\n        nuke.execute(WriteNodes.name()\[0], tuple(FrameRange))\n    # Multiple Write nodes...\n    else:\n        try:\n            # EX: nuke.execute(nodes, ranges, views, continueOnError=False) -- views is optional.\n            nuke.executeMultiple(tuple(WriteNodes), tuple(FrameRange))\n        except RuntimeError:\n            nuke.critical('nuke.executeMultiple failed. Exported images are probably OK, though.\\nCheck for last .tmp file that may not have been deleted...')\n\n    for node in WriteNodes:\n        nuke.delete(node)\n    for node in ShuffleNodes:\n        nuke.delete(node)\n\n    GroupNode.end()\n\n\ndef write_consolidated_EXR_layers_to_single_file(destDir):\n    ''''''\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    # Get the valid and the empty layers...\n    layers_to_export = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[0]\n    layers_to_remove = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[1]\n\n    ##############################################################\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create the Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    ##############################################################\n    # Add a Crop node to make sure that Photoshop won't lose a pixel,\n    # based on a misinterpretation of the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\n    WriteNode = nuke.createNode('Write', inpanel=False)\n    # Get original Read node's basename...\n    FileName = Source.get_info(ConnectedNode)\['Filename']\n    WriteNode.knob('file').setValue(destDir + FileName)\n    WriteNode.knob('use_limit').setValue(True)\n    WriteNode.knob('first').setValue(first)\n    WriteNode.knob('last').setValue(last)\n    WriteNode.knob('channels').setValue('all')\n    # Make sure the Write node's input is connected to the Shuffle...\n    WriteNode.setInput(0, cropnode)\n\n    # Execute() takes a string for the node name, executeMultiple() takes a tuple of node objects...\n    # Single Write node...\n    print WriteNode.name()\n    print 'FrameRange', FrameRange\n    ##nuke.execute(WriteNode.name(), tuple(FrameRange))\n    nuke.execute(WriteNode.name(), first, last, 1)\n\n    ##############################################################\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed.'\n    nuke.delete(WriteNode)\n\n    GroupNode.end()\n\n\n#------------------------------------------------------------------------\n# RUN IT...\n\nif user_input:\n    destDir = directory_path_check(user_input)\n    if GroupNode.knob('exr_consolidate').value() == True:\n        write_consolidated_EXR_layers_to_single_file(destDir)\n    else:\n        # Get the selected image file type to render...\n        FileType = GroupNode.knob('filetype').value()        \n        write_layers_to_separate_files(destDir, FileType)\nelse:\n    print 'Nothing entered for Output Directory.'\n    nuke.message('Nothing entered for Output Directory.')" +STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos -226
  ypos 100
 }
set N755bec00 [stack 0]
 Output {
  name Output1
  xpos -226
  ypos 241
 }
push $N755bec00
 Write {
  channels all
  file_type exr
  on_error black
  version 8
  in_colorspace "ACES - ACEScg"
  out_colorspace "ACES - ACEScg"
  name Write_EXR
  selected true
  xpos -618
  ypos 397
  addUserKnob {20 Metadata_Tab l Metadata}
  addUserKnob {26 ICC_Section_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">ICC Profile (JPG, PNG & TIF images):<\\FONT>"}
  addUserKnob {4 ICC_knob l "" +STARTLINE M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc REC2020.icc "ACESCG Linear.icc"}}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {26 divider2B l "" +STARTLINE}
  addUserKnob {26 IPTC_Section_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">IPTC Data (TIF images only - Required for Innocean/Hyundai projects):<\\FONT>"}
  addUserKnob {6 IPTC_knob l "Armstrong White Contact/Author Data" +STARTLINE}
  addUserKnob {26 divider3 l "" +STARTLINE}
  addUserKnob {26 divider3B l "" +STARTLINE}
  addUserKnob {26 Hyundai_Folders_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">Views-Based Comp:<\\FONT>"}
  addUserKnob {6 Hyundai_knob l "Rearrange Folders per Innocean/Hyundai requirements." +STARTLINE}
 }
end_group
push $N7a91800
Group {
 name Layer_Exporter
 knobChanged "\ndef knobChanged():\n    Node = nuke.thisNode()\n    Knob = nuke.thisKnob()\n    if Knob.name() == 'filetype':\n        if Knob.value() == 'exr':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setEnabled(True)\n        elif Knob.value() == 'tga':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\n        else:\n            Node.knob('icc_profile').setEnabled(True)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\nknobChanged()\n"
 selected true
 xpos -305
 ypos 143
 addUserKnob {20 auto_tab l Automatic}
 addUserKnob {26 ""}
 addUserKnob {2 dest_dir l "Output Directory:"}
 dest_dir C:/Users/rbobo/Desktop/TESTING/CRAP_17/
 addUserKnob {26 ""}
 addUserKnob {68 filetype l "Image Type:" M {png tif jpg exr tga}}
 addUserKnob {6 exr_consolidate l "Consolidate Layers (Single EXR File)" t "Instead of rendering the layers to separate files, just remove empty layers and save to a new EXR file." +DISABLED +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {68 icc_profile l "ICC Profile:" M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc Rec2020.icc "ACESCG Linear.icc"}}
 icc_profile sRGB.icc
 addUserKnob {26 ""}
 addUserKnob {22 do_it l "Do it." T "import nuke\nimport EXR_Layer_Exporter.EXR_ValidLayers_Checker as LayersChecker\nimport CollectSourceFiles.SourceNodeInfo\n\n#------------------------------------------------------------------------\n# The Group node itself...\nGroupNode = nuke.thisNode()\n\n# Get the EXR Read node connected to the Group's input...\ntry:\n    ConnectedNode = GroupNode.input(0)\n    if (ConnectedNode.Class() == 'Read') and (os.path.splitext(nuke.filename(ConnectedNode))\[-1] == \".exr\"):\n        pass\n    else:\n        nuke.message(\"Please connect an EXR file to the input!\")\nexcept AttributeError:\n    nuke.message(\"Please connect an EXR file to the input!\")\n\n# The Output Directory knob for the user to set...\nuser_input = GroupNode.knob('dest_dir').value()\n\n# ICC Profile to add to image...\nICC_Profile_Name = GroupNode.knob('icc_profile').value()\n\n# Initialize the NodeInfo class to get parameters from the Read node...\nSource = CollectSourceFiles.SourceNodeInfo.NodeInfo()\n#READINFO = Source.get_info(ConnectedNode).items()\n#READINFO.sort()\n#print '\\n'\n#for k, v in READINFO:\n    #print k, '---->', v\n\n# Get first and last frame numbers from Read node...\nfirst = Source.get_info(ConnectedNode)\['firstFrame']\nlast = Source.get_info(ConnectedNode)\['lastFrame']\n# Set the frame range to be rendered...\nFrameRange = \[(int(first), int(last), 1)]\n\n#------------------------------------------------------------------------\ndef directory_path_check(user_input):\n    '''\n    Make sure the destination directory path is of the correct form...\n    '''\n    destDir = ''\n    if user_input != '':\n        destDir = user_input\n        # Check to make sure a file path is not passed through.\n        # If splitext \[1] result is empty, we're good...\n        if os.path.splitext(destDir)\[1] == '':\n            # Make sure target path ends with a slash (for consistency)\n            if not destDir.endswith('/'):\n                destDir += '/'\n            # Put the reformatted directory path back in the knob...\n            GroupNode.knob('dest_dir').setValue(destDir)\n        else:\n            temp_dir = os.path.splitext(destDir)\n            destDir = os.path.dirname(temp_dir\[0])          \n            # Make sure target path ends with a slash (for consistency)\n            if not destDir.endswith('/'):\n                destDir += '/'\n            # Put the reformatted directory path back in the knob...\n            GroupNode.knob('dest_dir').setValue(destDir)\n            if nuke.ask('Filename not allowed.\\nPath has been changed to a directory format.\\nPlease re-check for correctness.\\n\\nContinue?'):\n                pass\n            else:\n                destDir = False\n    # Return the chosen directory path...\n    return destDir    \n\ndef write_layers_to_separate_files(destDir, FileType=''):\n    ''''''\n    if destDir == False:\n        return\n\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    #--------------------------------------------------------------------------------\n    #  NODE REMOVALS\n    #--------------------------------------------------------------------------------\n    # Remove any leftover group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class() == ('Write') and Node.name() == 'Write_EXR':\n                pass\n            elif Node.Class() == ('Input'):\n                pass\n            elif Node.Class() == ('Output'):\n                pass\n            else:\n                nuke.delete(Node)      \n    except ValueError:\n        print 'Value Error: Check in Group for nodes that were not deleted...'    \n    #--------------------------------------------------------------------------------\n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    WriteNodes = \[]\n    ShuffleNodes = \[]\n\n    # Get only the non-empty layers...\n    layers = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[0]\n    print 'layers', layers\n\n    # Get the selected image file type to render...\n    FileType = GroupNode.knob('filetype').value()\n\n    for layer in layers:\n        ShuffleNode = nuke.createNode('Shuffle', inpanel=False)\n        ShuffleNode.knob('in').setValue(str(layer))\n        # Make sure the Shuffle node's input is connected to the Group's Input node...\n        ShuffleNode.setInput(0, InputNode)\n        ShuffleNodes.append(ShuffleNode)\n\n        WriteNode = nuke.createNode('Write', inpanel=False)\n        WriteNode.knob('file').setValue(str(destDir) + str(layer) + '_%04d' + '.' + FileType)\n        WriteNode.knob('use_limit').setValue(True)\n        WriteNode.knob('first').setValue(first)\n        WriteNode.knob('last').setValue(last)\n        # Make sure the Write node's input is connected to the Shuffle...\n        WriteNode.setInput(0, ShuffleNode)\n        # Add selected ICC Profile...\n        WriteNode.knob('ICC_knob').setValue(ICC_Profile_Name)\n        if layer is not 'rgba':\n            WriteNode.knob('channels').setValue('rgb')\n        else:\n            WriteNode.knob('channels').setValue('rgba')\n        WriteNodes.append(WriteNode)\n        print 'WriteNodes', WriteNodes\n\n    if WriteNodes:\n        if len(WriteNodes) == 1:\n            # Single Write node...\n            # nuke.execute() takes a string for the node name...\n            # EX: nuke.execute(nodes, ranges, views, continueOnError=False) -- views is optional.            \n            print 'SINGLE'\n            nuke.execute(WriteNodes.name()\[0], first, last, 1)\n        else:\n            print 'MULTIPLE'\n            # Multiple Write nodes:\n            # executeMultiple() takes a tuple of node objects...\n            try:\n                nuke.executeMultiple(tuple(WriteNodes), tuple(FrameRange))\n            except RuntimeError:\n                nuke.critical('nuke.executeMultiple failed. Exported images are probably OK, though.\\nCheck for last .tmp file that may not have been deleted...')\n    else:\n        nuke.critical('Only one rgba layer in EXR file!')\n        return None \n\n    # Cleanup nodes...\n    for node in WriteNodes:\n        nuke.delete(node)\n    for node in ShuffleNodes:\n        nuke.delete(node)\n    # Finishe Group operations...\n    GroupNode.end()\n\n\ndef write_consolidated_EXR_layers_to_single_file(destDir):\n    ''''''\n    if destDir == False:\n        return\n\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    #--------------------------------------------------------------------------------\n    #  NODE REMOVALS\n    #--------------------------------------------------------------------------------\n    # Remove any leftover group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class() == ('Write') and Node.name() == 'Write_EXR':\n                pass\n            elif Node.Class() == ('Input'):\n                pass\n            elif Node.Class() == ('Output'):\n                pass\n            else:\n                nuke.delete(Node)      \n    except ValueError:\n        print 'Value Error: Check in Group for nodes that were not deleted...'    \n    #--------------------------------------------------------------------------------    \n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    # Get the valid and the empty layers...\n    layers_to_export = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[0]\n    layers_to_remove = LayersChecker.EXR_ValidLayers_Checker(InputNode)\[1]\n\n    #----------------------------------------------------------------------\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create the Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    #----------------------------------------------------------------------\n    # Add a Crop node to make sure that Photoshop won't lose a pixel,\n    # based on a misinterpretation of the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\n    WriteNode = nuke.createNode('Write', inpanel=False)\n    # Get original Read node's basename...\n    FileName = Source.get_info(ConnectedNode)\['Filename']\n    WriteNode.knob('file').setValue(destDir + FileName)\n    WriteNode.knob('use_limit').setValue(True)\n    WriteNode.knob('first').setValue(first)\n    WriteNode.knob('last').setValue(last)\n    WriteNode.knob('channels').setValue('all')\n    # Make sure the Write node's input is connected to the Shuffle...\n    WriteNode.setInput(0, cropnode)\n\n    # Execute() takes a string for the node name, executeMultiple() takes a tuple of node objects...\n    # Single Write node...\n    nuke.execute(WriteNode.name(), first, last, 1)\n\n    #----------------------------------------------------------------------\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed.'\n    nuke.delete(WriteNode)\n\n    GroupNode.end()\n\n\n#------------------------------------------------------------------------\n# RUN IT...\nif user_input:\n    destDir = directory_path_check(user_input)\n    if GroupNode.knob('exr_consolidate').value() == True:\n        write_consolidated_EXR_layers_to_single_file(destDir)\n    else:\n        # Get the selected image file type to render...\n        FileType = GroupNode.knob('filetype').value()        \n        write_layers_to_separate_files(destDir, FileType)\nelse:\n    print 'Nothing entered for Output Directory.'\n    nuke.message('Nothing entered for Output Directory.')" +STARTLINE}
 addUserKnob {20 manual_tab l Manual}
 addUserKnob {26 ""}
 addUserKnob {26 step_one l "1) Check for EXR Layers:" -STARTLINE}
 addUserKnob {22 check_for_layers l Update -STARTLINE T "import re\n\n# The Group node itself...\nGroupNode = nuke.thisNode()\n\n# Get all the knobs in the Group...\nGroupNodeKnobs = GroupNode.allKnobs()\n\n# Get the EXR Read node connected to the Group's input...\ntry:\n    ConnectedNode = GroupNode.input(0)\n    if (ConnectedNode.Class() == 'Read') and (os.path.splitext(nuke.filename(ConnectedNode))\[-1] == \".exr\"):\n        pass\n    else:\n        nuke.message(\"Please connect an EXR file to the input!\")\nexcept AttributeError:\n    nuke.message(\"Please connect an EXR file to the input!\")\n\n#----------------------------------------------------------------------\n#                 LAYER DETECTION\n#----------------------------------------------------------------------\n# Get all the layers contained in an EXR image file and put them into a layers list...\ntry:\n    if ConnectedNode:\n        channels = ConnectedNode.channels()\n        layers = list(set(\[c.split('.')\[0] for c in channels]))\n        layers.sort()\nexcept NameError:\n    nuke.message(\"No image channels found.\")\n\n#----------------------------------------------------------------------\n#                KNOB REMOVALS\n#----------------------------------------------------------------------\n# Set up some variables for removal of preexisting knobs when the Update button is pressed...\nknobs_to_remove = \[]\n\n# Also, make sure to ignore the exr_consolidate knob on the Automatic tab which should stay there...\nknobs_to_ignore = \['exr_consolidate', 'selected', 'hide_input', 'cached', 'dope_sheet', 'bookmark', 'postage_stamp', 'useLifetime', 'lock_connections']\n# Make a list of any checkbox (Boolean_Knob) knobs...\nregex = re.compile(r\"\\WBoolean_Knob\\W\")   # \\W is anything but a word character...\nfor knob in GroupNodeKnobs:\n    if bool(regex.search(str(type(knob)))):\n        if knob.name() not in knobs_to_ignore:\n            name = knob.name()\n            knobs_to_remove.append(name)\n        else:\n            pass\n# Get all the knob objects...\nKnobs = GroupNode.knobs()\n# Remove any old checkboxes (Boolean_Knob) when the Update button is pressed, before we make new ones...\ntry:\n    for knobname in knobs_to_remove:\n        GroupNode.removeKnob(Knobs\[knobname])\nexcept KeyError:\n    print 'Key Error: Some nonexistant knobs could not be removed.'\nexcept ValueError:\n    print 'Value Error: Some nonexistant knobs could not be removed.'\n# Also delete these additional knobs, so they don't multiply like rabbits...\ntry:\n    GroupNode.removeKnob(Knobs\['select_all'])\n    GroupNode.removeKnob(Knobs\['invert_selection'])\n    GroupNode.removeKnob(Knobs\['newline'])\n    GroupNode.removeKnob(Knobs\['step_three'])\n    GroupNode.removeKnob(Knobs\['build_button'])\n    GroupNode.removeKnob(Knobs\['newline2'])\n    GroupNode.removeKnob(Knobs\['step_four'])\n    # Remove the knobs originating from the \"Write_EXR\" node that always stays in the group...  \n    GroupNode.removeKnob(Knobs\['file'])\n    GroupNode.removeKnob(Knobs\['Render'])\nexcept KeyError:\n    print 'Key Error: Some nonexistant knobs could not be removed.'\nexcept ValueError:\n    print 'Value Error: Some nonexistant knobs could not be removed.'\n\n#----------------------------------------------------------------------\n#             NODE REMOVALS\n#----------------------------------------------------------------------\n\n# Remove any existing group nodes...\nAllNodes = \[node for node in GroupNode.nodes()]\ntry:\n    for Node in AllNodes:\n        if Node.Class()==('Crop'):\n            nuke.delete(Node)\n        elif Node.Class()==('Remove'):\n            nuke.delete(Node)      \nexcept ValueError:\n    print 'Value Error: Probably not a problem...'\n\n#----------------------------------------------------------------------\n#            ADD KNOBS\n#----------------------------------------------------------------------\n\n# Add knobs for 'Select All' and 'Invert Selection' checkboxes...\nselect_all_button = nuke.PyScript_Knob('select_all', 'Select All', '''\nfor knob in checkboxKnobs:\n    knob.setValue(True)\n''')\nGroupNode.addKnob(select_all_button)\nselect_all_button.setFlag(nuke.STARTLINE)\n\ninvert_selection_button = nuke.PyScript_Knob('invert_selection', 'Invert Selection', '''\ndef invertSelection():\n    for checkbox in checkboxKnobs:\n        if checkbox.value():\n            checkbox.setValue(False)\n        else:\n            checkbox.setValue(True)    \ninvertSelection()\n''')\nGroupNode.addKnob(invert_selection_button)\n\n# Add new checkbox knobs, based on the layer names found in the input EXR Read node...\ncheckboxKnobs = \[]\ntry:\n    if layers:\n        for layer in layers:\n            Knob_string = 'nuke.' + 'Boolean_Knob' + '(' + \"'\" + layer + \"'\" + ', ' + \"'\" + layer + \"'\" + ')'\n            Knob = eval(Knob_string)\n            GroupNode.addKnob(Knob)\n            Knob.setFlag(nuke.STARTLINE)\n            # Keep a list of all the created knobs for re-use...\n            checkboxKnobs.append(Knob)\nexcept NameError:\n    nuke.message(\"No image channels found.\")\n# Separator...\nnewline_knob = nuke.Text_Knob('newline', '')\nGroupNode.addKnob(newline_knob)\n# Step 3...\nstep_three_knob = nuke.Text_Knob('step_three', '3) Rebuild the Layers:')\nGroupNode.addKnob(step_three_knob)\n\n#----------------------------------------------------------------------\n#           ADD NODES\n#----------------------------------------------------------------------\n\n# Make a PyScript button to do all the node building stuff...\nBuildButton = nuke.PyScript_Knob('build_button', 'Assemble Layers', '''\ndef Doit():\n\n    GroupNode = nuke.thisNode()\n\n    ##############################################################\n\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed.'\n\n    ##############################################################\n\n    checkboxesDict = \{\}\n    layers_to_export = \[]\n    layers_to_remove = \[]\n    for checkbox in checkboxKnobs:\n        checkbox_value = checkbox.value()\n        checkboxesDict\[checkbox.name()] = checkbox_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select some layers for export!')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n\n    ##############################################################\n\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create the Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    ##############################################################\n\n    # Add a Crop node to make sure that Photoshop won't lose a pixel,\n    # based on a misinterpretation of the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\nDoit()\n''')\n# Add the Build button knob...\nGroupNode.addKnob(BuildButton)\n\n# Add a separator...\nnewline_knob2 = nuke.Text_Knob('newline2', '')\nGroupNode.addKnob(newline_knob2)\n\n# Step 4...\nstep_four_knob = nuke.Text_Knob('step_four', '4) Full path - with .exr extension: ')\nGroupNode.addKnob(step_four_knob)\n\n# Get the persistant Write_EXR node's file knob and add it...\nWrite = nuke.toNode('Write_EXR')\nFileKnob = Write.knob('file')\nGroupNode.addKnob(FileKnob)\nFileKnob.setFlag(nuke.STARTLINE)\n\n# Get the Write_EXR node's Render button knob and add it...\nRenderButton = Write.knob('Render')\nGroupNode.addKnob(RenderButton)\nRenderButton.setFlag(nuke.STARTLINE)"}
 addUserKnob {26 ""}
 addUserKnob {26 step_two l "2) Select Layers for Export:"}
 addUserKnob {22 select_all l "Select All" T "\nfor knob in checkboxKnobs:\n    knob.setValue(True)\n" +STARTLINE}
 addUserKnob {22 invert_selection l "Invert Selection" -STARTLINE T "\ndef invertSelection():\n    for checkbox in checkboxKnobs:\n        if checkbox.value():\n            checkbox.setValue(False)\n        else:\n            checkbox.setValue(True)    \ninvertSelection()\n"}
 addUserKnob {6 rgba +STARTLINE}
 addUserKnob {26 newline l "" +STARTLINE}
 addUserKnob {26 step_three l "3) Rebuild the Layers:"}
 addUserKnob {22 build_button l "Assemble Layers" -STARTLINE T "\ndef Doit():\n\n    GroupNode = nuke.thisNode()\n\n    ##############################################################\n\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed.'\n\n    ##############################################################\n\n    checkboxesDict = \{\}\n    layers_to_export = \[]\n    layers_to_remove = \[]\n    for checkbox in checkboxKnobs:\n        checkbox_value = checkbox.value()\n        checkboxesDict\[checkbox.name()] = checkbox_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select some layers for export!')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n\n    ##############################################################\n\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create the Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    ##############################################################\n\n    # Add a Crop node to make sure that Photoshop won't lose a pixel,\n    # based on a misinterpretation of the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\nDoit()\n"}
 addUserKnob {26 newline2 l "" +STARTLINE}
 addUserKnob {26 step_four l "4) Full path - with .exr extension: "}
 addUserKnob {2 file}
 addUserKnob {22 Render t "Press this to render image files" T "nukescripts.render_panel((nuke.thisNode(),), False)" +STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 365
  ypos -573
 }
set N7603fc00 [stack 0]
 Output {
  name Output1
  xpos 365
  ypos -329
 }
push $N7603fc00
 Write {
  channels all
  raw true
  file_type exr
  on_error black
  version 11
  name Write_EXR
  xpos -24
  ypos -45
  addUserKnob {20 Metadata_Tab l Metadata}
  addUserKnob {26 ICC_Section_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">ICC Profile (JPG, PNG & TIF images):<\\FONT>"}
  addUserKnob {4 ICC_knob l "" +STARTLINE M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc REC2020.icc "ACESCG Linear.icc"}}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {26 divider2B l "" +STARTLINE}
  addUserKnob {26 IPTC_Section_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">IPTC Data (TIF images only - Required for Innocean/Hyundai projects):<\\FONT>"}
  addUserKnob {6 IPTC_knob l "Armstrong White Contact/Author Data" +STARTLINE}
  addUserKnob {26 divider3 l "" +STARTLINE}
  addUserKnob {26 divider3B l "" +STARTLINE}
  addUserKnob {26 Hyundai_Folders_Title l "" +STARTLINE T "<FONT COLOR=\"#7777EE\">Views-Based Comp:<\\FONT>"}
  addUserKnob {6 Hyundai_knob l "Rearrange Folders per Innocean/Hyundai requirements." +STARTLINE}
 }
end_group
