set cut_paste_input [stack 0]
version 10.5 v7
push $cut_paste_input
Group {
 name Layer_Exporter
 knobChanged "\ndef knobChanged():\n\n    Node = nuke.thisNode()\n    Knob = nuke.thisKnob()\n\n    # \"Automatic\" Tab knobs...\n    if Knob.name() == 'filetype':\n        if Knob.value() == 'exr':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setEnabled(True)\n        elif Knob.value() == 'tga':\n            Node.knob('icc_profile').setValue('Empty')\n            Node.knob('icc_profile').setEnabled(False)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\n        else:\n            Node.knob('icc_profile').setEnabled(True)\n            Node.knob('exr_consolidate').setValue(False)\n            Node.knob('exr_consolidate').setEnabled(False)\n\n    # \"Manual\" Tab knobs...\n    if Knob.name() == 'filetype2':\n        if Knob.value() == 'exr':\n            Node.knob('icc_profile2').setValue('Empty')\n            Node.knob('icc_profile2').setEnabled(False)\n            Node.knob('exr_consolidate2').setEnabled(True)\n        elif Knob.value() == 'tga':\n            Node.knob('icc_profile2').setValue('Empty')\n            Node.knob('icc_profile2').setEnabled(False)\n            Node.knob('exr_consolidate2').setValue(False)\n            Node.knob('exr_consolidate2').setEnabled(False)\n        else:\n            Node.knob('icc_profile2').setEnabled(True)\n            Node.knob('exr_consolidate2').setValue(False)\n            Node.knob('exr_consolidate2').setEnabled(False)\n\nknobChanged()\n"
 selected true
 xpos -37
 ypos -198
 addUserKnob {20 auto_tab l Automatic}
 addUserKnob {26 title_auto l "AUTO OUTPUT EXR LAYERS: " T "(Automatically removes empty layers.)"}
 addUserKnob {26 ""}
 addUserKnob {2 dest_dir l "Output Directory:"}
 addUserKnob {68 filetype l "Image Type:" M {png tif jpg exr tga}}
 addUserKnob {6 exr_consolidate l "Consolidate Layers (Single EXR File)" t "Instead of rendering the layers to separate files, just remove empty layers and save to a new EXR file." +DISABLED +STARTLINE}
 addUserKnob {68 icc_profile l "ICC Profile:" M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc REC2020.icc "ACESCG Linear.icc" ""}}
 icc_profile sRGB.icc
 addUserKnob {26 ""}
 addUserKnob {22 do_it l "Do it." T "import EXR_Layer_Exporter.Auto_Do_It\nEXR_Layer_Exporter.Auto_Do_It.run_it()" +STARTLINE}
 addUserKnob {20 manual_tab l Manual}
 addUserKnob {26 title_manual l "SELECT EXR LAYERS TO OUTPUT: " T "(Follow the steps below.)"}
 addUserKnob {26 ""}
 addUserKnob {26 step_one l "1) Scan for All EXR Layers:" -STARTLINE}
 addUserKnob {22 check_for_layers l Scan -STARTLINE T "import EXR_Layer_Exporter.Manual_Scan\nEXR_Layer_Exporter.Manual_Scan.run_it()"}
 addUserKnob {26 ""}
 addUserKnob {26 step_two l "2) Select Layers for Export:"}
 addUserKnob {22 select_all l "Select All" T "def select_all_checkbox_knobs():\n    import nuke\n    import re\n    GroupNode = nuke.thisNode()\n    # Make a list of all the checkbox knobs (Boolean_Knob)...\n    checkboxKnobs = \[]\n    # Also, make sure to ignore the exr_consolidate knob on the Automatic tab...\n    knobs_to_ignore = \['exr_consolidate', 'exr_consolidate2', 'selected', 'hide_input', 'cached', 'dope_sheet', 'bookmark', 'postage_stamp', 'useLifetime', 'lock_connections']\n    # Make a list of any checkbox (Boolean_Knob) knobs...\n    regex = re.compile(r\"\\WBoolean_Knob\\W\")   # \\W is anything but a word character...\n    # Start with a list of all the Group's knobs...\n    AllKnobs = GroupNode.knobs()\n    for name, knob in AllKnobs.iteritems():\n        if bool(regex.search(str(type(knob)))):\n            if knob.name() not in knobs_to_ignore:\n                name = knob.name()\n                checkboxKnobs.append(knob)\n            else:\n                pass\n    for knob in checkboxKnobs:\n        knob.setValue(True)\nselect_all_checkbox_knobs() " +STARTLINE}
 addUserKnob {22 invert_selection l "Invert Selection" -STARTLINE T "def invertSelection_checkbox_knobs():\n    import nuke\n    import re\n    GroupNode = nuke.thisNode()\n    # Make a list of all the checkbox knobs (Boolean_Knob)...\n    checkboxKnobs = \[]\n    # Also, make sure to ignore the exr_consolidate knob on the Automatic tab...\n    knobs_to_ignore = \['exr_consolidate', 'exr_consolidate2', 'selected', 'hide_input', 'cached', 'dope_sheet', 'bookmark', 'postage_stamp', 'useLifetime', 'lock_connections']\n    # Make a list of any checkbox (Boolean_Knob) knobs...\n    regex = re.compile(r\"\\WBoolean_Knob\\W\")   # \\W is anything but a word character...\n    # Start with a list of all the Group's knobs...\n    AllKnobs = GroupNode.knobs()\n    for name, knob in AllKnobs.iteritems():\n        if bool(regex.search(str(type(knob)))):\n            if knob.name() not in knobs_to_ignore:\n                name = knob.name()\n                checkboxKnobs.append(knob)\n            else:\n                pass\n    for knob in checkboxKnobs:\n        if knob.value():\n            knob.setValue(False)\n        else:\n            knob.setValue(True)\ninvertSelection_checkbox_knobs()\n    "}
 addUserKnob {6 rgba +STARTLINE}
 addUserKnob {26 newline2 l "" +STARTLINE}
 addUserKnob {26 step_three l "3) Set the Image Parameters:"}
 addUserKnob {2 dest_dir2 l "Output Directory:"}
 addUserKnob {4 filetype2 l "Image Type:" M {png tif jpg exr tga}}
 addUserKnob {6 exr_consolidate2 l "Consolidate Layers (Single EXR File)" +DISABLED +STARTLINE}
 addUserKnob {4 icc_profile2 l "ICC Profile:" M {Empty sRGB.icc AdobeRGB1998.icc REC709.icc Rec2020.icc "ACESCG Linear.icc"}}
 icc_profile2 sRGB.icc
 addUserKnob {26 newline5 l "" +STARTLINE}
 addUserKnob {26 press_the_button l "4) Press the \"Do it.\" Button! :"}
 addUserKnob {22 do_it2 l "Do it." -STARTLINE T "\nimport nuke\nimport CollectSourceFiles.SourceNodeInfo\nimport re\n\n#------------------------------------------------------------------------\n# The Group node itself...\nGroupNode = nuke.thisNode()\n\n# Get the EXR Read node connected to the Group's input...\ntry:\n    ConnectedNode = GroupNode.input(0)\n    if (ConnectedNode.Class() == 'Read') and (os.path.splitext(nuke.filename(ConnectedNode))\[-1] == \".exr\"):\n        pass\n    else:\n        nuke.message(\"Please connect an EXR file to the input!\")\nexcept AttributeError:\n    nuke.message(\"Please connect an EXR file to the input!\")\n\n# The Output Directory knob for the user to set...\n##user_input = GroupNode.knob('dest_dir2').value()\n\n# ICC Profile to add to image...\nICC_Profile_Name = GroupNode.knob('icc_profile2').value()\n\n# Initialize the NodeInfo class to get parameters from the Read node...\nSource = CollectSourceFiles.SourceNodeInfo.NodeInfo()\n\n# Get first and last frame numbers from Read node...\nfirst = Source.get_info(ConnectedNode)\['firstFrame']\nlast = Source.get_info(ConnectedNode)\['lastFrame']\n# Set the frame range to be rendered...\nFrameRange = \[(int(first), int(last), 1)]\n#------------------------------------------------------------------------\n\ndef get_layers(ConnectedNode):\n    # Get the layers from the EXR...\n    channels = ConnectedNode.channels()\n    #print 'channels', channels\n    layers = list(set(\[c.split('.')\[0] for c in channels]))\n    layers.sort()\n    return layers\n\ndef get_checkbox_knobs():\n    # Make a list of all the checkbox knobs (Boolean_Knob)...\n    checkboxKnobsDict = \{\}\n    checkboxKnobs = \[]\n    # Also, make sure to ignore the exr_consolidate knob on the Automatic tab...\n    knobs_to_ignore = \['exr_consolidate', 'exr_consolidate2', 'selected', 'hide_input', 'cached', 'dope_sheet', 'bookmark', 'postage_stamp', 'useLifetime', 'lock_connections']\n    # Make a list of any checkbox (Boolean_Knob) knobs...\n    regex = re.compile(r\"\\WBoolean_Knob\\W\")   # \\W is anything but a word character...\n    # Start with a list of all the Group's knobs...\n    AllKnobs = GroupNode.knobs()\n    for name, knob in AllKnobs.iteritems():\n        #print name, knob\n        if bool(regex.search(str(type(knob)))):\n            if knob.name() not in knobs_to_ignore:\n                name = knob.name()\n                #print name\n                checkboxKnobsDict\[name] = knob\n            else:\n                pass\n    #print 'checkboxKnobsDict', checkboxKnobsDict\n    return checkboxKnobsDict\n\ndef directory_path_check():\n    destDir = GroupNode.knob('dest_dir2').value()\n    if destDir:\n        # Check to make sure a file path is not passed through.\n        # If splitext \[1] result is empty, we're good...\n        if os.path.splitext(destDir)\[1] == '':\n            # Make sure target path ends with a slash (for consistency)\n            if not destDir.endswith('/'):\n                destDir += '/'\n            # Put the reformatted directory path back in the knob...\n            GroupNode.knob('dest_dir2').setValue(destDir)\n        else:\n            temp_dir = os.path.splitext(destDir)\n            destDir = os.path.dirname(temp_dir\[0])          \n            # Make sure target path ends with a slash (for consistency)\n            if not destDir.endswith('/'):\n                destDir += '/'\n            # Put the reformatted directory path back in the knob...\n            GroupNode.knob('dest_dir2').setValue(destDir)\n            if nuke.ask('Filename not allowed. Path has been changed to a directory format. Please re-check for correctness. Continue?'):\n                pass\n            else:\n                destDir = False\n    # Return the chosen directory path...\n    return destDir\n\ndef cleanup_nodes():\n    try:\n        for Node in GroupNode.nodes():\n            if Node.Class() == ('Input'):\n                pass\n            elif Node.Class() == ('Output'):\n                pass\n            else:\n                nuke.delete(Node)      \n    except ValueError:\n        print \"Value Error: Check in Group for nodes that were not deleted...\"\n\ndef write_layers_to_separate_files(destDir, FileType=''):\n    if destDir == False:\n        return\n\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    # Remove any leftover group nodes...\n    cleanup_nodes()\n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    WriteNodes = \[]\n    ShuffleNodes = \[]\n\n    # Build a dict of the checkbox names and their respective knob objects...\n    checkboxKnobsDict = get_checkbox_knobs()\n\n    # Get a list of all the layers...\n    layers = get_layers(ConnectedNode)\n\n    # Initialize the user-selected layers...\n    layers_to_export = \[]\n    layers_to_remove = \[]\n\n    # Create a dict that will contain all the checkbox names and their knob objects (and eventually their boolean value)...\n    checkboxesDict = \{\}\n    for checkbox, knob in checkboxKnobsDict.iteritems():\n        knob_value = knob.value()\n        checkboxesDict\[checkbox] = knob_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            # Build a list of layers_to_export by getting the corresponding layer object from layers...by using the checkbox knobnames...\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select some layers for export!')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n\n    # Get the selected image file type to render...\n    FileType = GroupNode.knob('filetype2').value()\n\n    for layer in layers_to_export:\n        ShuffleNode = nuke.createNode('Shuffle', inpanel=False)\n        ShuffleNode.knob('in').setValue(str(layer))\n        # Make sure the Shuffle node's input is connected to the Group's Input node...\n        ShuffleNode.setInput(0, InputNode)\n        ShuffleNodes.append(ShuffleNode)\n\n        WriteNode = nuke.createNode('Write', inpanel=False)\n        WriteNode.knob('file').setValue(str(destDir) + str(layer) + '_%04d' + '.' + FileType)\n        WriteNode.knob('use_limit').setValue(True)\n        WriteNode.knob('first').setValue(first)\n        WriteNode.knob('last').setValue(last)\n        # Make sure the Write node's input is connected to the Shuffle...\n        WriteNode.setInput(0, ShuffleNode)\n        # Add selected ICC Profile...\n        WriteNode.knob('ICC_knob').setValue(ICC_Profile_Name)\n        if layer is not 'rgba':\n            WriteNode.knob('channels').setValue('rgb')\n        else:\n            WriteNode.knob('channels').setValue('rgba')\n        WriteNodes.append(WriteNode)\n\n    if WriteNodes:\n        if len(WriteNodes) == 1:\n            # Single Write node...\n            # nuke.execute() takes a string for the node name...\n            # EX: nuke.execute(nodes, ranges, views, continueOnError=False) -- views is optional.            \n            try:\n                nuke.execute(WriteNodes\[0], first, last, 1)\n            except RuntimeError as error:\n                status = str(error)\n                # Catch the user's Cancel button press...\n                if \"Cancelled\" in status:\n                    cleanup_nodes()\n                    nuke.critical('Cancelled. Check for any .tmp files that may remain in the output folder...')\n                    return\n        else:\n            # Multiple Write nodes:\n            # executeMultiple() takes a tuple of node objects...\n            try:\n                nuke.executeMultiple(tuple(WriteNodes), tuple(FrameRange))\n            except RuntimeError as error:\n                status = str(error)\n                # Catch the user's Cancel button press...\n                if \"Cancelled\" in status:\n                    cleanup_nodes()\n                    nuke.critical('Cancelled.Check for any .tmp files that may remain in the output folder...')\n                    return\n                else:\n                    cleanup_nodes()\n                    nuke.critical('nuke.executeMultiple failed. Exported images are probably OK, though. Check for last .tmp file that may not have been deleted...')\n                    return\n    else:\n        nuke.critical('Only one rgba layer in EXR file!')\n        return None \n\n    # Cleanup remaining nodes...\n    cleanup_nodes()\n\n    # Finish Group operations...\n    GroupNode.end()\n\n\ndef write_consolidated_EXR_layers_to_single_file(destDir):\n\n    if destDir == False:\n        return\n\n    # Start working inside the Group's context...\n    GroupNode.begin()\n\n    # Remove any leftover group nodes...\n    cleanup_nodes()    \n\n    # The Input node inside the Group, which is connected to the Read node on the Group's input...\n    InputNode = nuke.toNode('Input1')\n\n    # Build a dict of the checkbox names and their respective knob objects...\n    checkboxKnobsDict = get_checkbox_knobs()\n\n    # Get a list of all the layers...\n    layers = get_layers(ConnectedNode)\n\n    # Initialize the user-selected layers...\n    layers_to_export = \[]\n    layers_to_remove = \[]\n\n    # Create a dict that will contain all the checkbox names and their knob objects (and eventually their boolean value)...\n    checkboxesDict = \{\}\n    for checkbox, knob in checkboxKnobsDict.iteritems():\n        knob_value = knob.value()\n        checkboxesDict\[checkbox] = knob_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            # Build a list of layers_to_export by getting the corresponding layer object from layers...by using the checkbox knobnames...\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select some layers for export!')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n\n    #----------------------------------------------------------------------\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create the Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    #----------------------------------------------------------------------\n    # Add a Crop node to make sure that Photoshop won't lose a pixel,\n    # based on a misinterpretation of the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\n    WriteNode = nuke.createNode('Write', inpanel=False)\n    # Get original Read node's basename...\n    Filename = Source.get_info(ConnectedNode)\['FilenameForRelink']\n    WriteNode.knob('file').setValue(destDir + Filename)\n    WriteNode.knob('use_limit').setValue(True)\n    WriteNode.knob('first').setValue(first)\n    WriteNode.knob('last').setValue(last)\n    WriteNode.knob('channels').setValue('all')\n    # Make sure the Write node's input is connected to the Shuffle...\n    WriteNode.setInput(0, cropnode)\n\n    # Execute() takes a string for the node name, executeMultiple() takes a tuple of node objects...\n    # Single Write node...\n    try:\n        nuke.execute(WriteNode.name(), first, last, 1)\n    except RuntimeError as error:\n        status = str(error)\n        if \"Cancelled\" in status:\n            cleanup_nodes()\n            nuke.critical('Cancelled. Check for any .tmp files that may remain in the output folder...')\n            return\n\n    #----------------------------------------------------------------------\n    # Remove existing internal group nodes...\n    cleanup_nodes()\n\n    GroupNode.end()\n\n#------------------------------------------------------------------------\n# RUN IT...\ndestDir = directory_path_check()\nif GroupNode.knob('exr_consolidate2').value() == True:\n    write_consolidated_EXR_layers_to_single_file(destDir)\nelse:\n    # Get the selected image file type to render...\n    FileType = GroupNode.knob('filetype2').value()        \n    write_layers_to_separate_files(destDir, FileType)\n    "}
}
 Input {
  inputs 0
  name Input1
  xpos 365
  ypos -573
 }
end_group
